From 023a879f34ba90d81054290fc192223492c914c8 Mon Sep 17 00:00:00 2001
From: root <root@andreiw-eng-rhel5-64.(none)>
Date: Mon, 7 Nov 2011 22:56:06 -0500
Subject: [PATCH] Loop: Tentative loop/parser changes.

Signed-off-by: root <root@andreiw-eng-rhel5-64.(none)>
---
 drivers/block/loop.c     |   82 ++++++++++++++++++++++++++-------------------
 drivers/block/qcowloop.c |   25 +++++++-------
 drivers/block/vhdloop.c  |    7 +---
 include/linux/loop.h     |   15 ++++----
 4 files changed, 68 insertions(+), 61 deletions(-)

diff --git a/drivers/block/loop.c b/drivers/block/loop.c
index 6f2a076..5a68a06 100644
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -165,7 +165,7 @@ static struct loop_func_table *xfer_funcs[MAX_LO_CRYPT] = {
 static int
 figure_loop_size(struct loop_device *lo)
 {
-  loff_t size = lo->lo_parser->size(lo, lo->lo_file);
+	loff_t size = lo->lo_file->parser->size(lo, lo->lo_file);
 	sector_t x = (sector_t) size;
 
 	if (unlikely((loff_t) x != size))
@@ -485,7 +485,7 @@ static int do_bio_filebacked(struct loop_device *lo, struct bio *bio)
 	if (bio_rw(bio) == WRITE) {
 
 		if (bio->bi_rw & REQ_FLUSH) {
-			ret = lo->lo_parser->sync(lo, lo->lo_file);
+			ret = lo->lo_file->parser->sync(lo, lo->lo_file);
 
 			if (unlikely(ret && ret != -EINVAL)) {
 				ret = -EIO;
@@ -493,10 +493,10 @@ static int do_bio_filebacked(struct loop_device *lo, struct bio *bio)
 			}
 		}
 
-		ret = lo->lo_parser->bio(lo, lo->lo_file, bio);
+		ret = lo->lo_file->parser->bio(lo, lo->lo_file, bio);
 
 		if ((bio->bi_rw & REQ_FUA) && !ret) {
-			ret = lo->lo_parser->sync(lo, lo->lo_file);
+			ret = lo->lo_file->parser->sync(lo, lo->lo_file);
 
 			if (unlikely(ret && ret != -EINVAL)) {
 				ret = -EIO;
@@ -504,7 +504,7 @@ static int do_bio_filebacked(struct loop_device *lo, struct bio *bio)
 			}
 		}
 	} else
-		ret = lo->lo_parser->bio(lo, lo->lo_file, bio);
+		ret = lo->lo_file->parser->bio(lo, lo->lo_file, bio);
 
 out:
 	return ret;
@@ -661,6 +661,9 @@ static int loop_match_parser(struct loop_device *lo, struct lo_file *lo_file)
 	struct module *owner;
 	int ret = 0;
 
+	if (lo_file->parser)
+		return 0;
+
 	mutex_lock(&loop_parsers_mutex);
 	list_for_each_entry(parser, &loop_parsers, list) {
 		owner = parser->owner;
@@ -670,7 +673,7 @@ static int loop_match_parser(struct loop_device *lo, struct lo_file *lo_file)
 
 		ret = parser->init(lo, lo_file);
 		if (!ret) {
-			lo->lo_parser = parser;
+			lo_file->parser = parser;
 			break;
 		}
 
@@ -686,9 +689,9 @@ static int loop_match_parser(struct loop_device *lo, struct lo_file *lo_file)
 	 * unless a parser noted that the file is supported, but
 	 * losetup should be denied.
 	 */
-	if(!lo->lo_parser && ret != -EPERM) {
-		lo->lo_parser = &raw_parser;
-		lo->lo_parser->init(lo, lo_file);
+	if(!lo_file->parser && ret != -EPERM) {
+		lo_file->parser = &raw_parser;
+		lo_file->parser->init(lo, lo_file);
 		ret = 0;
 	}
 	return ret;
@@ -706,7 +709,7 @@ static struct lo_file *loop_lo_file_alloc(struct block_device *bdev,
 {
 	struct address_space *mapping;
 	struct lo_file *lo_file;
-	struct file *file, *f;
+	struct file *file;
 	unsigned blocksize;
 	struct inode *inode;
 	int lo_file_flags = 0;
@@ -719,22 +722,29 @@ static struct lo_file *loop_lo_file_alloc(struct block_device *bdev,
 	if (!file)
 		return ERR_PTR(-EBADF);
 
-	/* Avoid recursion */
-	f = file;
-	while (is_loop_device(f)) {
+	/*
+	 * Avoid nesting. We do not want multiple
+	 * lo_files and parsers attaching to the same file, 
+	 * from a data coherency point of view. This
+	 * also means you do not have to check for recursive
+	 * relationships, as a loop device will always bind
+	 * to the lo_file backing an existing loop device.
+	 */
+	if (is_loop_device(file)) {
 		struct loop_device *l;
 
-		if (f->f_mapping->host->i_bdev == bdev) {
-			error = -EBUSY;
-			goto out;
-		}
-
-		l = f->f_mapping->host->i_bdev->bd_disk->private_data;
+		l = file->f_mapping->host->i_bdev->bd_disk->private_data;
+		spin_lock_irq(&l->lo_lock);
 		if (l->lo_state == Lo_unbound) {
+			spin_unlock_irq(&l->lo_lock);
 			error = -EINVAL;
 			goto out;
 		}
-		f = l->lo_file->file;
+		lo_file = l->lo_file;
+		atomic_inc(&lo_file->ref);
+		spin_unlock_irq(&l->lo_lock);
+		fput(file);
+		return lo_file;
 	}
 
 	mapping = file->f_mapping;
@@ -774,16 +784,15 @@ out:
 }
 
 void loop_lo_file_put(struct loop_device *lo,
-		      struct loop_parser *parser,
 		      struct lo_file *lo_file)
 {
 	gfp_t gfp;
 	struct file *file = lo_file->file;
 
 	if (atomic_dec_and_test(&lo_file->ref)) {
-		if (parser) {
-			parser->release(lo, lo_file);
-			module_put(parser->owner);
+		if (lo_file->parser) {
+			lo_file->parser->release(lo, lo_file);
+			module_put(lo_file->parser->owner);
 		}
 
 		gfp = lo_file->old_gfp_mask;
@@ -827,6 +836,12 @@ static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
 		goto out;
 	}
 
+	/* Can't be trying to change to fd of a loop device!. */
+	if (lo_file->parser) { 
+		error = -EINVAL;
+		goto out;
+	}
+
 	/*
 	 * Policy and parser-specific logic changes
 	 * happen here. Note, after this call has
@@ -834,9 +849,10 @@ static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
 	 * deal with I/O going to old lo_file as
 	 * part of the flush happening during switch.
 	 */
-	error = lo->lo_parser->change(lo, lo->lo_file, lo_file);
+	error = old_lo_file->parser->change(lo, lo->lo_file, lo_file);
 	if (error)
 		goto out_putlf;
+	lo_file->parser = old_lo_file->parser;
 
 	/*
 	 * On an old-style fd-switch, the old lo_file
@@ -847,7 +863,7 @@ static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
 	 * parser's release call, so we will still be
 	 * balanced.
 	 */
-	__module_get(lo->lo_parser->owner);
+	__module_get(lo_file->parser->owner);
 
 	/* Perform flush + switch. */
 	error = loop_switch(lo, lo_file);
@@ -858,14 +874,14 @@ static int loop_change_fd(struct loop_device *lo, struct block_device *bdev,
 	 * Possibly free up - because it could be retained
 	 * for COW/differencing disk purposes.
 	 */
-	loop_lo_file_put(lo, lo->lo_parser, old_lo_file);
+	loop_lo_file_put(lo, old_lo_file);
 
 	if (max_part > 0)
 		ioctl_by_bdev(bdev, BLKRRPART, 0);
 	return 0;
 
 out_putlf:
-	loop_lo_file_put(lo, lo->lo_parser, lo_file);
+	loop_lo_file_put(lo, lo_file);
 out:
 	return error;
 }
@@ -994,7 +1010,7 @@ static int loop_set_fd(struct loop_device *lo, fmode_t mode,
 	error = loop_match_parser(lo, lo->lo_file);
 	if (error)
 		goto out_putlf;
-	size = lo->lo_parser->size(lo, lo->lo_file);
+	size = lo->lo_file->parser->size(lo, lo->lo_file);
 
 	if ((loff_t)(sector_t)size != size) {
 		error = -EFBIG;
@@ -1050,8 +1066,7 @@ out_clr:
 	kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, KOBJ_CHANGE);
 	lo->lo_state = Lo_unbound;
 out_putlf:
-	loop_lo_file_put(lo, lo->lo_parser, lo->lo_file);
-	lo->lo_parser = NULL;
+	loop_lo_file_put(lo, lo->lo_file);
 	lo->lo_file = NULL;
 out:
 	return error;
@@ -1097,7 +1112,6 @@ loop_init_xfer(struct loop_device *lo, struct loop_func_table *xfer,
 static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
 {
 	struct lo_file *lo_file;
-	struct loop_parser *parser;
 
 	if (lo->lo_state != Lo_bound)
 		return -ENXIO;
@@ -1115,8 +1129,6 @@ static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
 	kthread_stop(lo->lo_thread);
 
 	spin_lock_irq(&lo->lo_lock);
-	parser = lo->lo_parser;
-	lo->lo_parser = NULL;
 	lo_file = lo->lo_file;
 	lo->lo_file = NULL;
 	spin_unlock_irq(&lo->lo_lock);
@@ -1154,7 +1166,7 @@ static int loop_clr_fd(struct loop_device *lo, struct block_device *bdev)
 	 * lock dependency possibility warning as fput can take
 	 * bd_mutex which is usually taken before lo_ctl_mutex.
 	 */
-	loop_lo_file_put(lo, parser, lo_file);
+	loop_lo_file_put(lo, lo_file);
 	return 0;
 }
 
diff --git a/drivers/block/qcowloop.c b/drivers/block/qcowloop.c
index 6cb0e28f..90d19fe 100644
--- a/drivers/block/qcowloop.c
+++ b/drivers/block/qcowloop.c
@@ -189,6 +189,15 @@ static bool qcow_match_name(char *name,
 	return true;
 }
 
+static void qcow_free(struct qcow *qcow)
+{
+	if (qcow->backing) {
+		loop_lo_file_put(lo, qcow->backing);
+		kfree(qcow->backing_name);
+	}
+	kfree(qcow);
+}
+
 static int qcow_change(struct loop_device *lo,
 		       struct lo_file *old_lo_file,
 		       struct lo_file *new_lo_file)
@@ -201,7 +210,6 @@ static int qcow_change(struct loop_device *lo,
 		       QCOW_DNAME(qcow));
 		goto out;
 	}
-	new_lo_file->parser_priv = new_qcow;
 
 	if (qcow->header.size != new_qcow->header.size) {
 		printk(KERN_ERR "%s: changed-to image mismatched disk size\n",
@@ -231,10 +239,12 @@ static int qcow_change(struct loop_device *lo,
 		}
 	}
 
+	new_lo_file->parser_priv = new_qcow;
 	return 0;
 out:
 
-	/* Clean-up happens in loop_lo_file_put->qcow_release(). */
+	if (new_qcow)
+		qcow_free(new_qcow);
 	return -EINVAL;
 }
 
@@ -254,17 +264,8 @@ static int qcow_init(struct loop_device *lo, struct lo_file *lo_file)
 static void qcow_release(struct loop_device *lo, struct lo_file *lo_file)
 {
 	struct qcow *qcow = lo_file->parser_priv;
-
-	if (!qcow)
-		return;
-
+	qcow_free(qcow);
 	lo_file->parser_priv = NULL;
-	if (qcow->backing) {
-		loop_lo_file_put(lo, &qcow_parser,
-				 qcow->backing);
-		kfree(qcow->backing_name);
-	}
-	kfree(qcow);
 }
 
 static loff_t qcow_size(struct loop_device *lo, struct lo_file *lo_file)
diff --git a/drivers/block/vhdloop.c b/drivers/block/vhdloop.c
index f35020e..49a30f3 100644
--- a/drivers/block/vhdloop.c
+++ b/drivers/block/vhdloop.c
@@ -445,7 +445,6 @@ static int vhd_change(struct loop_device *lo,
 		       VHD_DNAME(vhd));
 		goto out;
 	}
-	new_lo_file->parser_priv = new_vhd;
 
 	if (vhd->size != new_vhd->size) {
 		printk(KERN_ERR "%s: changed-to image mismatched disk size\n",
@@ -469,10 +468,9 @@ static int vhd_change(struct loop_device *lo,
 		goto out;
 	}
 
+	new_lo_file->parser_priv = new_vhd;
 	return 0;
 out:
-	printk(KERN_ERR "%s: loop change aborted\n",
-	       VHD_DNAME(vhd));
 	if (new_vhd)
 		kfree(new_vhd);
 	return -EINVAL;
@@ -520,9 +518,6 @@ static void vhd_release(struct loop_device *lo, struct lo_file *lo_file)
 {
 	struct vhd *vhd = lo_file->parser_priv;
 
-	if (!vhd)
-		return;
-
 	vhd_sync(lo, lo_file);
 	lo_file->parser_priv = NULL;
 	kfree(vhd);
diff --git a/include/linux/loop.h b/include/linux/loop.h
index 1dc9d63..dcaeadf 100644
--- a/include/linux/loop.h
+++ b/include/linux/loop.h
@@ -36,12 +36,13 @@ enum {
 };
 
 struct lo_file {
-	int		flags;
-	struct file *	file;
-	unsigned	blocksize;
-	gfp_t		old_gfp_mask;
-	void *		parser_priv;
-	atomic_t	ref;
+	int			flags;
+	struct file *		file;
+	unsigned		blocksize;
+	gfp_t			old_gfp_mask;
+	atomic_t		ref;
+	struct loop_parser *	parser;
+	void *			parser_priv;
 };
 
 struct loop_device {
@@ -64,7 +65,6 @@ struct loop_device {
 	char		lo_encrypt_key[LO_KEY_SIZE];
 	int		lo_encrypt_key_size;
 	struct loop_func_table *lo_encryption;
-	struct loop_parser *lo_parser;
 	__u32           lo_init[2];
 	uid_t		lo_key_owner;	/* Who set the key */
 	int		(*ioctl)(struct loop_device *, int cmd,
@@ -187,7 +187,6 @@ struct loop_parser {
 int loop_register_parser(struct loop_parser *parser);
 int loop_unregister_parser(struct loop_parser *parser);
 void loop_lo_file_put(struct loop_device *lo,
-		      struct loop_parser *parser,
 		      struct lo_file *lo_file);
 int loop_send(struct loop_device *lo, struct lo_file *lo_file,
 	      struct bio *bio, loff_t pos, loop_xfer_t transfer);
-- 
1.7.4.1

