From 9b37a27f28d61af7dea6424ec126a5cbbc81e072 Mon Sep 17 00:00:00 2001
From: Andrei Warkentin <andrey.warkentin@gmail.com>
Date: Sat, 15 Oct 2011 02:21:45 -0400
Subject: [PATCH 2/4] Loop: Useful I/O routines shared by parsers.

This is basic functionality otherwise duplicated, like
reading/writing a kernel buffer or struct page. Also
provides a generic sparse I/O routine currently
shared by VHD and QCOW parsers.

Signed-off-by: Andrei Warkentin <andrey.warkentin@gmail.com>
---
 drivers/block/Kconfig    |    4 +
 drivers/block/Makefile   |    1 +
 drivers/block/looputil.c |  194 ++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/loop.h     |   33 ++++++++
 4 files changed, 232 insertions(+), 0 deletions(-)
 create mode 100644 drivers/block/looputil.c

diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 6f07ec1..326fd90 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -286,6 +286,10 @@ config BLK_DEV_CRYPTOLOOP
 	  instead, which can be configured to be on-disk compatible with the
 	  cryptoloop device.
 
+config BLK_DEV_LOOP_UTIL
+	bool
+	depends on BLK_DEV_LOOP
+
 source "drivers/block/drbd/Kconfig"
 
 config BLK_DEV_NBD
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index 76646e9..eb3df97 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_BLK_DEV_OSD)	+= osdblk.o
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
 obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryptoloop.o
+obj-$(CONFIG_BLK_DEV_LOOP_UTIL)	+= looputil.o
 obj-$(CONFIG_VIRTIO_BLK)	+= virtio_blk.o
 
 obj-$(CONFIG_VIODASD)		+= viodasd.o
diff --git a/drivers/block/looputil.c b/drivers/block/looputil.c
new file mode 100644
index 0000000..ab67a5e
--- /dev/null
+++ b/drivers/block/looputil.c
@@ -0,0 +1,194 @@
+/*
+   Useful routines shared by loop parsers.
+
+   Copyright (C) 2011 Andrei Warkentin <andreiw@vmware.com>
+
+   This module is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This module is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this module; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/loop.h>
+
+static int loop_kbuf_to_bio(struct bio *bio,
+			    u8 *kbuf,
+			    size_t len)
+{
+	unsigned int bv_len;
+	unsigned int bv_offset;
+	struct bio_vec *bvec;
+
+	/*
+	 * Fake a BIO containing bvec's describing a physically
+	 * contiguous kernel buffer. bio_add_page is too smart
+	 * and relies on a present rq. In our case, we just want
+	 * to use the same file I/O logic, which just happens to
+	 * use BIO. It might be nicer to redo everything in loop-ng
+	 * to use sg's and convert BIO nvecs to sg inside
+	 * do_bio_filebacked.
+	 */
+	while (len) {
+		bv_offset = ((uintptr_t) kbuf) & ~PAGE_MASK;
+		bv_len = min(len, (unsigned int) PAGE_SIZE - bv_offset);
+		bvec = &bio->bi_io_vec[bio->bi_vcnt];
+		bvec->bv_page = virt_to_page(kbuf);
+		bvec->bv_len = bv_len;
+		bvec->bv_offset = bv_offset;
+		bio->bi_vcnt++;
+		len -= bv_len;
+		kbuf += bv_len;
+	}
+	return 0;
+}
+
+int loop_write_kbuf(struct loop_device *lo,
+		    struct lo_file *lo_file,
+		    void *kbuf,
+		    size_t len,
+		    loff_t pos)
+{
+	int ret;
+	unsigned nr_vecs = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	struct bio *bio = bio_alloc(GFP_KERNEL, nr_vecs);
+
+	ret = loop_kbuf_to_bio(bio, (u8 *) kbuf, len);
+	if (ret)
+		goto out;
+
+	ret = loop_send(lo, lo_file, bio, pos, NULL);
+out:
+	bio_put(bio);
+	return ret;
+}
+
+int loop_read_kbuf(struct loop_device *lo,
+		   struct lo_file *lo_file,
+		   void *kbuf,
+		   size_t len,
+		   loff_t pos)
+{
+	int ret;
+	unsigned nr_vecs = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	struct bio *bio = bio_alloc(GFP_KERNEL, nr_vecs);
+
+	ret = loop_kbuf_to_bio(bio, (u8 *) kbuf, len);
+	if (ret)
+		goto out;
+
+	ret = loop_recv(lo, lo_file, bio, pos, NULL);
+out:
+	bio_put(bio);
+	return ret;
+}
+
+int loop_read_page(struct loop_device *lo,
+		   struct lo_file *lo_file,
+		   struct page *page,
+		   unsigned int offset,
+		   unsigned int len,
+		   loff_t pos)
+{
+	int ret;
+	struct bio *bio = bio_alloc(GFP_KERNEL, 1);
+	bio->bi_io_vec->bv_page = page;
+	bio->bi_io_vec->bv_offset = offset;
+	bio->bi_io_vec->bv_len = len;
+	bio->bi_vcnt = 1;
+	ret = loop_recv(lo, lo_file, bio, pos, NULL);
+	bio_put(bio);
+	return ret;
+}
+
+int loop_write_page(struct loop_device *lo,
+		    struct lo_file *lo_file,
+		    struct page *page,
+		    unsigned int offset,
+		    unsigned int len,
+		    loff_t pos)
+{
+	int ret;
+	struct bio *bio = bio_alloc(GFP_KERNEL, 1);
+	bio->bi_io_vec->bv_page = page;
+	bio->bi_io_vec->bv_offset = offset;
+	bio->bi_io_vec->bv_len = len;
+	bio->bi_vcnt = 1;
+	ret = loop_send(lo, lo_file, bio, pos, NULL);
+	bio_put(bio);
+	return ret;
+}
+
+static int loop_sparse_bvec(struct loop_device *lo,
+			    struct bio *bio,
+			    struct bio_vec *bvec,
+			    loff_t pos,
+			    loop_sparse_to sparse_to)
+{
+	u8 *raw_buf;
+	unsigned int len;
+	int ret = 0;
+	loff_t fpos = 0;
+	struct lo_file *lo_file = &lo->lo_file;
+	unsigned int bv_len = bvec->bv_len;
+
+	while (bv_len) {
+		len = bv_len;
+		ret  = sparse_to(&lo_file, bio, pos, &len, &fpos);
+
+		if (ret == -ENOENT && bio_rw(bio) != WRITE) {
+			ret = 0;
+			raw_buf = kmap_atomic(bvec->bv_page, KM_USER0) +
+				bvec->bv_offset + bvec->bv_len - bv_len;
+			memset(raw_buf, 0, len);
+			kunmap_atomic(raw_buf, KM_USER0);
+		} else if (!ret) {
+			if (bio_rw(bio) == WRITE)
+				ret = loop_write_page(lo, lo_file, bvec->bv_page,
+						      bvec->bv_offset + bvec->bv_len -
+						      bv_len, len, fpos);
+			else
+				ret = loop_read_page(lo, lo_file, bvec->bv_page,
+						     bvec->bv_offset + bvec->bv_len -
+						     bv_len, len, fpos);
+		}
+
+		if (ret) {
+			printk(KERN_ERR "%s: failed to %s: %d\n",
+			       lo->lo_disk->disk_name,
+                               bio_rw(bio) == WRITE ? "write" : "read",
+			       ret);
+			break;
+		}
+
+		bv_len -= len;
+		pos += len;
+	}
+
+	return ret;
+}
+
+int loop_sparse_io(struct loop_device *lo,
+		   struct bio *bio,
+		   loop_sparse_to sparse_to)
+{
+	struct bio_vec *bvec;
+	int i = 0;
+	int ret = 0;
+	loff_t pos = ((loff_t) bio->bi_sector << 9);
+
+	bio_for_each_segment(bvec, bio, i) {
+		ret = loop_sparse_bvec(lo, bio, bvec, pos, sparse_to);
+		pos += bvec->bv_len;
+	}
+
+	return ret;
+}
diff --git a/include/linux/loop.h b/include/linux/loop.h
index 222534f..4ffde53 100644
--- a/include/linux/loop.h
+++ b/include/linux/loop.h
@@ -186,6 +186,39 @@ int loop_send(struct loop_device *lo, struct lo_file *lo_file,
 int loop_recv(struct loop_device *lo, struct lo_file *lo_file,
 	      struct bio *bio, loff_t pos, loop_xfer transfer);
 int loop_sync(struct loop_device *lo, struct lo_file *lo_file);
+
+#ifdef CONFIG_BLK_DEV_LOOP_UTIL
+int loop_write_kbuf(struct loop_device *lo,
+		    struct lo_file *lo_file,
+		    void *kbuf,
+		    size_t len,
+		    loff_t pos);
+int loop_read_kbuf(struct loop_device *lo,
+		   struct lo_file *lo_file,
+		   void *kbuf,
+		   size_t len,
+		   loff_t pos);
+int loop_read_page(struct loop_device *lo,
+		   struct lo_file *lo_file,
+		   struct page *page,
+		   unsigned int offset,
+		   unsigned int len,
+		   loff_t pos);
+int loop_write_page(struct loop_device *lo,
+		    struct lo_file *lo_file,
+		    struct page *page,
+		    unsigned int offset,
+		    unsigned int len,
+		    loff_t pos);
+typedef int (*loop_sparse_to)(struct lo_file **lo_file,
+			      struct bio *bio,
+			      loff_t pos,
+			      unsigned int *len,
+			      loff_t *fpos);
+int loop_sparse_io(struct loop_device *lo,
+		   struct bio *bio,
+		   loop_sparse_to sparse_to);
+#endif /* CONFIG_BLK_DEV_LOOP_UTIL */
 #endif
 /*
  * IOCTL commands --- we will commandeer 0x4C ('L')
-- 
1.7.7

