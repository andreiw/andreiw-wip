From 1237d3888b3c805a6fd952e802fb167a0b257962 Mon Sep 17 00:00:00 2001
From: Andrei Warkentin <andrey.warkentin@gmail.com>
Date: Mon, 17 Oct 2011 01:17:22 -0400
Subject: [PATCH 4/5] Loop: QCOW loop parser implementation.

Beginnings of QCOW support (v1, read/write).

I think a hallmark of good design isn't just
time and space considerations, but also ease
of implementation. It's roughly 3 hours to
implement the QCOW (v1) logic and test. It's
been about 8 to implement and test dynamic
VHD - and you get better use of unallocated
space for QCOW.

Ex: for 100m qcow and VHD at default settings,
empty disks take up 448 and 2.5k respectively.
Formatted with mkfs.ext2, they take up 3.3m
and 24.3m respectively. Astounding.

QCOW parser now uses the parser metadata cache
manager.

Signed-off-by: Andrei Warkentin <andrey.warkentin@gmail.com>

qcow cha

Signed-off-by: Andrei Warkentin <andrey.warkentin@gmail.com>
---
 drivers/block/Kconfig    |    8 +
 drivers/block/Makefile   |    1 +
 drivers/block/qcowloop.c |  361 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 370 insertions(+), 0 deletions(-)
 create mode 100644 drivers/block/qcowloop.c

diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index c7f391e..ed14cbc 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -298,6 +298,14 @@ config BLK_DEV_VHDLOOP
 	  Say Y here if you want to be able to use VHD images
 	  as disks using the loop device.
 
+config BLK_DEV_QCOWLOOP
+	tristate "QCOW loop support"
+	depends on BLK_DEV_LOOP
+	select BLK_DEV_LOOP_UTIL
+	---help---
+	  Say Y here if you want to be able to use QCOW images
+	  as disks using the loop device.
+
 source "drivers/block/drbd/Kconfig"
 
 config BLK_DEV_NBD
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index caf5b8e..619635c 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
 obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryptoloop.o
 obj-$(CONFIG_BLK_DEV_LOOP_UTIL)	+= looputil.o
 obj-$(CONFIG_BLK_DEV_VHDLOOP)	+= vhdloop.o
+obj-$(CONFIG_BLK_DEV_QCOWLOOP)	+= qcowloop.o
 obj-$(CONFIG_VIRTIO_BLK)	+= virtio_blk.o
 
 obj-$(CONFIG_VIODASD)		+= viodasd.o
diff --git a/drivers/block/qcowloop.c b/drivers/block/qcowloop.c
new file mode 100644
index 0000000..b8a777d
--- /dev/null
+++ b/drivers/block/qcowloop.c
@@ -0,0 +1,361 @@
+/*
+   Linux loop QCOW support.
+
+   Copyright (C) 2011 Andrei Warkentin <andreiw@vmware.com>
+
+   This module is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This module is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this module; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/loop.h>
+#include <linux/looputil.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("loop QCOW parser");
+MODULE_AUTHOR("Andrei Warkentin <andreiw@vmware.com>");
+
+#define QCOW_MAGIC		(*(u32 *) "QFI\xfb")
+#define QCOW_DNAME(qcow)	((qcow)->lo->lo_disk->disk_name)
+#define L1_SIZE(entries)	((entries) * sizeof(u64))
+#define L2_SIZE(entries)	((entries) * sizeof(u64))
+#define B2M(bits)		((1 << (bits)) - 1)
+#define SEC_SHIFT		(9)
+#define SEC_SZ			(1 << SEC_SHIFT)
+
+struct qcow_header {
+	u32 magic;
+	u32 version;
+
+	u64 backing_file_offset;
+	u32 backing_file_size;
+	u32 mtime;
+
+	u64 size;
+
+	u8 cluster_bits;
+	u8 l2_bits;
+	u32 crypt_method;
+
+	u64 l1_table_offset;
+};
+
+struct qcow
+{
+	struct loop_device *lo;
+	struct lo_file     *lo_file;
+	struct qcow_header header;
+	loff_t file_size;
+
+	/* Parsed and created from header. */
+	u64 *l1;
+	u64 l1_entries;
+	u64 l2_entries;
+	loff_t cluster_size;
+	unsigned int access_size;
+	struct loop_pmc *l2;
+
+/* L1 table needs to be flushed. */
+#define QCOW_L1_DIRTY (0x1)
+	unsigned flags;
+};
+
+static int qcow_l2_load(struct loop_pmc *pmc,
+			struct loop_pmce *pmce)
+{
+	loff_t l2pos;
+	struct qcow *qcow = pmc->context;
+	l2pos = be64_to_cpu(qcow->l1[pmce->index]);
+
+	if (!l2pos) {
+		l2pos = qcow->file_size;
+		qcow->file_size += L2_SIZE(qcow->l2_entries);
+		qcow->l1[pmce->index] = cpu_to_be64(l2pos);
+		qcow->flags |= QCOW_L1_DIRTY;
+		return 0;
+	}
+
+	if (l2pos > qcow->file_size ||
+	    l2pos + L2_SIZE(qcow->l2_entries) > qcow->file_size)
+		return -EINVAL;
+
+	return loop_read_kbuf(qcow->lo, qcow->lo_file, &pmce->data,
+			      L2_SIZE(qcow->l2_entries), l2pos);
+}
+
+static int qcow_l2_flush(struct loop_pmc *pmc,
+			 struct loop_pmce *pmce)
+{
+	struct qcow *qcow = pmc->context;
+	return loop_write_kbuf(qcow->lo, qcow->lo_file, &pmce->data,
+			       L2_SIZE(qcow->l2_entries),
+			       be64_to_cpu(qcow->l1[pmce->index]));
+}
+
+static int qcow_verify(struct qcow *qcow)
+{
+	int ret;
+
+	qcow->header.version = be32_to_cpu(qcow->header.version);
+	if (qcow->header.version != 1) {
+		printk(KERN_ERR "%s: unsupported version %d\n",
+		       QCOW_DNAME(qcow),
+		       qcow->header.version);
+		return -EINVAL;
+	}
+
+	qcow->header.backing_file_offset = be64_to_cpu(qcow->header.backing_file_offset);
+	qcow->header.backing_file_size = be32_to_cpu(qcow->header.backing_file_size);
+	if (qcow->header.backing_file_offset > qcow->file_size ||
+	    (qcow->header.backing_file_offset +
+	     qcow->header.backing_file_size) > qcow->file_size) {
+		printk(KERN_ERR "%s: corrupt backing file data\n",
+		       QCOW_DNAME(qcow));
+		return -EINVAL;
+	}
+
+	qcow->header.size = be64_to_cpu(qcow->header.size);
+	qcow->header.crypt_method = be32_to_cpu(qcow->header.crypt_method);
+
+	if (qcow->header.crypt_method != 0) {
+		printk(KERN_ERR "%s: encryption unsupported\n",
+		       QCOW_DNAME(qcow));
+		return -EINVAL;
+	}
+	qcow->header.l1_table_offset = be64_to_cpu(qcow->header.l1_table_offset);
+
+	qcow->cluster_size = 1 << qcow->header.cluster_bits;
+	qcow->access_size = (unsigned int) min(qcow->cluster_size, (loff_t) PAGE_SIZE);
+	qcow->l2_entries = 1 << qcow->header.l2_bits;
+	qcow->l1_entries = qcow->header.size;
+	qcow->l1_entries = round_up(qcow->l1_entries, qcow->l2_entries * qcow->cluster_size);
+	do_div(qcow->l1_entries, qcow->l2_entries * qcow->cluster_size);
+
+	qcow->l1 = kzalloc(L1_SIZE(qcow->l1_entries), GFP_KERNEL);
+	if (!qcow->l1)
+		return -ENOMEM;
+
+	ret = loop_read_kbuf(qcow->lo, qcow->lo_file, qcow->l1,
+			     L1_SIZE(qcow->l1_entries),
+			     qcow->header.l1_table_offset);
+	if (ret)
+		return ret;
+
+	qcow->l2 = loop_pmc_init(qcow,
+				 L2_SIZE(qcow->l2_entries),
+				 QCOW_DNAME(qcow),
+				 qcow->l1_entries,
+				 qcow_l2_load, qcow_l2_flush);
+	if (IS_ERR(qcow->l2)){
+		qcow->l2 = NULL;
+		ret = PTR_ERR(qcow->l2);
+	}
+	return ret;
+}
+
+static int qcow_meta_flush(struct qcow *qcow)
+{
+	int ret;
+
+	if (qcow->l2) {
+		ret = loop_pmc_flush(qcow->l2);
+		if (ret)
+			goto out;
+	}
+
+	if (qcow->flags & QCOW_L1_DIRTY) {
+		ret = loop_write_kbuf(qcow->lo, qcow->lo_file, qcow->l1,
+				      L1_SIZE(qcow->l1_entries),
+				      qcow->header.l1_table_offset);
+		if (ret)
+			goto out;
+		else
+			qcow->flags ^= QCOW_L1_DIRTY;
+	}
+out:
+	if (ret)
+		printk(KERN_ERR "%s: failed to flush meta\n",
+		       QCOW_DNAME(qcow));
+	return 0;
+}
+
+static void qcow_free(struct qcow *qcow)
+{
+
+	if (qcow_meta_flush(qcow))
+		printk(KERN_ERR "%s: failed to flush metadata, expect corruption\n",
+		       QCOW_DNAME(qcow));
+
+	if (qcow->l2)
+		loop_pmc_free(qcow->l2);
+
+	if (qcow->l1)
+		kfree(qcow->l1);
+
+	kfree(qcow);
+}
+
+static int qcow_init(struct loop_device *lo, struct lo_file *lo_file)
+{
+	int ret;
+	struct qcow *qcow;
+
+	qcow = kzalloc(sizeof(struct qcow), GFP_KERNEL);
+	if (!qcow)
+		return -ENOMEM;
+
+	qcow->lo = lo;
+	qcow->lo_file = lo_file;
+	qcow->file_size = i_size_read(lo_file->file->f_mapping->host);
+	ret = loop_read_kbuf(lo, lo_file, &qcow->header,
+			     sizeof(qcow->header),
+			     0);
+	if (ret)
+		goto out;
+
+	if (qcow->header.magic != QCOW_MAGIC) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = qcow_verify(qcow);
+	if (ret) {
+		/* Invalid format, ensure other parsers don't bind. */
+		ret = -EPERM;
+		goto out;
+	}
+
+	printk(KERN_INFO "%s: QCOW %lld bytes\n",
+	       QCOW_DNAME(qcow),
+	       qcow->header.size);
+	lo_file->parser_priv = qcow;
+out:
+	if (ret)
+		qcow_free(qcow);
+	return ret;
+}
+
+static void qcow_release(struct loop_device *lo, struct lo_file *lo_file)
+{
+	struct qcow *qcow = lo_file->parser_priv;
+	lo_file->parser_priv = NULL;
+	qcow_free(qcow);
+}
+
+static loff_t qcow_size(struct loop_device *lo)
+{
+	struct qcow *qcow = lo->lo_file.parser_priv;
+	return qcow->header.size >> SEC_SHIFT;
+}
+
+static int qcow_sync(struct loop_device *lo)
+{
+	int ret;
+	struct qcow *qcow = lo->lo_file.parser_priv;
+
+	ret = qcow_meta_flush(qcow);
+	if (ret)
+		return ret;
+
+	return loop_sync(lo, &lo->lo_file);
+}
+
+static int qcow_sparse_to(struct lo_file **lo_file,
+			  struct bio *bio,
+			  loff_t pos,
+			  unsigned int *len,
+			  loff_t *fpos)
+{
+	loff_t ffpos;
+	u64 l2_index;
+	struct loop_pmce *pmce;
+	struct qcow *qcow = (*lo_file)->parser_priv;
+	u64 l1_index = pos >> (qcow->header.l2_bits +
+			       qcow->header.cluster_bits);
+	*len = min(*len, (unsigned int) ((qcow->access_size -
+					  (pos & (qcow->access_size - 1)))));
+
+	if (l1_index >= qcow->l1_entries)
+		return -EINVAL;
+
+	if (bio_rw(bio) != WRITE &&
+	    !be64_to_cpu(qcow->l1[l1_index]))
+		return -ENOENT;
+
+	pmce = loop_pmc_get(qcow->l2, l1_index, bio_rw(bio) == WRITE);
+	if (IS_ERR(pmce))
+		return PTR_ERR(pmce);
+
+	l2_index = pos >> qcow->header.cluster_bits &
+		B2M(qcow->header.l2_bits);
+
+	ffpos = be64_to_cpu(((u64 *)(&pmce->data))[l2_index]);
+	if (!ffpos) {
+		if (bio_rw(bio) != WRITE) {
+			loop_pmc_put(qcow->l2, pmce, false);
+			return -ENOENT;
+		}
+
+		ffpos = qcow->file_size;
+		qcow->file_size += qcow->cluster_size;
+		((u64 *)(&pmce->data))[l2_index] =
+			cpu_to_be64(ffpos);
+		loop_pmc_put(qcow->l2, pmce, true);
+	} else
+		loop_pmc_put(qcow->l2, pmce, false);
+
+	ffpos += pos & B2M(qcow->header.cluster_bits);
+	if (ffpos > qcow->file_size ||
+	    (ffpos + *len) > qcow->file_size)
+		return -EINVAL;
+
+	*fpos = ffpos;
+	return 0;
+}
+
+static int qcow_bio(struct loop_device *lo, struct bio *bio)
+{
+	return loop_sparse_io(lo, bio, qcow_sparse_to);
+}
+
+static struct loop_parser qcow_parser =
+{
+	.name = "qcow",
+	.init = qcow_init,
+	.release = qcow_release,
+	.sync = qcow_sync,
+	.size = qcow_size,
+	.bio = qcow_bio,
+	.owner = THIS_MODULE
+};
+
+static int __init
+init_qcowloop(void)
+{
+	int ret = loop_register_parser(&qcow_parser);
+	if (ret)
+		printk(KERN_ERR "qcowloop: loop_register_parser failed\n");
+	return ret;
+}
+
+static void __exit
+cleanup_qcowloop(void)
+{
+	if (loop_unregister_parser(&qcow_parser))
+		printk(KERN_ERR "qcowloop: loop_unregister_parser failed\n");
+}
+
+module_init(init_qcowloop);
+module_exit(cleanup_qcowloop);
-- 
1.7.7

